<?php

declare(strict_types=1);

namespace PhpList\Core\Tests\Unit\Composer;

use Composer\Package\PackageInterface;
use PhpList\Core\Composer\ModuleFinder;
use PhpList\Core\Composer\PackageRepository;
use PHPUnit\Framework\MockObject\MockObject;
use PHPUnit\Framework\TestCase;
use Symfony\Component\Yaml\Yaml;

/**
 * Testcase.
 *
 * @author Oliver Klee <oliver@phplist.com>
 */
class ModuleFinderTest extends TestCase
{
    private const YAML_COMMENT = '# This file is autogenerated. Please do not edit.';

    private ModuleFinder $subject;
    private PackageRepository|MockObject $packageRepository;

    protected function setUp(): void
    {
        $this->packageRepository = $this->createMock(PackageRepository::class);
        $this->subject = new ModuleFinder();
        $this->subject->injectPackageRepository($this->packageRepository);
    }

    public function testFindBundleClassesForNoModulesReturnsEmptyArray(): void
    {
        $this->packageRepository
            ->method('findModules')
            ->willReturn([]);

        $result = $this->subject->findBundleClasses();

        self::assertSame([], $result);
    }

    public function modulesWithoutBundlesDataProvider(): array
    {
        return $this->buildMockPackagesWithModuleConfiguration([
            'one module without/with empty extras' => [[]],
            'one module with extras for other stuff' => [['branch-alias' => ['dev-master' => '5.0.x-dev']]],
            'one module with empty "phplist/core" extras section' => [['phplist/core' => []]],
            'one module with empty bundles extras section' => [['phplist/core' => ['bundles' => []]]],
        ]);
    }

    private function buildMockPackagesWithModuleConfiguration(array $extrasSets): array
    {
        $moduleSets = [];
        foreach ($extrasSets as $packageName => $extrasSet) {
            $moduleSet = [];
            foreach ($extrasSet as $extras) {
                $moduleSet[] = $this->buildMockPackage($extras, $packageName);
            }
            $moduleSets[$packageName] = [$moduleSet];
        }

        return $moduleSets;
    }

    private function buildMockPackage(array $extras, string $packageName): PackageInterface
    {
        $package = $this->createMock(PackageInterface::class);
        $package->method('getExtra')->willReturn($extras);
        $package->method('getName')->willReturn($packageName);

        return $package;
    }

    /**
     * @dataProvider modulesWithoutBundlesDataProvider
     */
    public function testFindBundleClassesForModulesWithoutBundlesReturnsEmptyArray(array $modules): void
    {
        $this->packageRepository
            ->method('findModules')
            ->willReturn($modules);

        $result = $this->subject->findBundleClasses();

        self::assertSame([], $result);
    }

    public function modulesWithInvalidBundlesDataProvider(): array
    {
        return $this->buildMockPackagesWithModuleConfiguration([
            'one module with core section as string' => [['phplist/core' => 'foo']],
            'one module with bundles section as int' => [['phplist/core' => ['bundles' => 42]]],
        ]);
    }

    /**
     * @dataProvider modulesWithInvalidBundlesDataProvider
     */
    public function testFindBundleClassesForModulesWithInvalidBundlesConfigurationThrowsException(array $modules): void
    {
        $this->packageRepository
            ->method('findModules')
            ->willReturn($modules);

        $this->expectException(\InvalidArgumentException::class);
        $this->subject->findBundleClasses();
    }

    public function modulesWithBundlesDataProvider(): array
    {
        return [
            'one module with one bundle' => [
                [
                    $this->buildMockPackage([
                        'phplist/core' => [
                            'bundles' => ['Symfony\\Bundle\\FrameworkBundle\\FrameworkBundle'],
                        ],
                    ], 'phplist/foo'),
                ],
                ['phplist/foo' => ['Symfony\\Bundle\\FrameworkBundle\\FrameworkBundle']],
            ],
        ];
    }

    /**
     * @dataProvider modulesWithBundlesDataProvider
     */
    public function testFindBundleClassesForModulesWithBundlesReturnsBundleClassNames(
        array $modules,
        array $expectedBundles
    ): void {
        $this->packageRepository
            ->method('findModules')
            ->willReturn($modules);

        $result = $this->subject->findBundleClasses();

        self::assertSame($expectedBundles, $result);
    }

    public function testCreateBundleConfigurationYamlForNoModulesReturnsCommentOnly(): void
    {
        $this->packageRepository
            ->method('findModules')
            ->willReturn([]);

        $result = $this->subject->createBundleConfigurationYaml();

        self::assertSame(self::YAML_COMMENT . "\n{  }", $result);
    }

    /**
     * @dataProvider modulesWithBundlesDataProvider
     */
    public function testCreateBundleConfigurationYamlReturnsYamlForBundles(array $modules, array $bundles): void
    {
        $this->packageRepository
            ->method('findModules')
            ->willReturn($modules);

        $result = $this->subject->createBundleConfigurationYaml();

        self::assertSame(self::YAML_COMMENT . "\n" . Yaml::dump($bundles), $result);
    }
}
